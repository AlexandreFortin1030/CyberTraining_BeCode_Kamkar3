##### The following presentations is tailored to explain the basics of computer memory through a pratical example.
I propose the viewers to create a simple file. The file is then erased and recovered using Photorec, a basic foresic tool for data recovery.
The different steps it take for the file to be written in the memory and erased are discussed at the "bit level".
Ultimately, a bash script using the <shred> command is introduced, and the results verifyed using Photorec once again. 
The aim is to bring awareness on the steps needed to securely erase sensitive files.
 





### Disclaimer: The way memory works and therefore most of the steps and tools that will be used in this presentation rely on the file system of a machine or a disk.
The explaination is then limited to the file system "ext4" and linux systems. However, I believe that it still gives a general idea of computer memory. 
   

------ PART 1: Writing process ------


Intro: Earth, wind and Fire, Do you remember song (first 35 seconds).


### 1. Create a file on your desktop with a list of your worst kinks.
### 2. Name it secret.txt, save it and close it.

// What Happened??
-----> We know that the memory of a computer is divided into bits which store values of 0 or 1 (Binary computing). So the operation we just went through is a write operation where a serie of bits have been altered to remember our text file and it's content. However, the write process is not really happening that way. If our system would write on every bit one after the other it would take a loooot of time. 
Let's take an example: let's say that every bit is an empty square and that we have a stamp. Then we would have to hit a looooot of squares with our stamp, and that would be very time consuming.
What happens instead is that our system divides the memory into larger units of memory called "memory blocks". These memory blocks are in fact composed of either 4, 8, 16 or sometimes more kilo bits of data. This is around 4, 8 or 16 thousand times more than a single bit... Then when it's time for a "write" operation, it uses a huge stamp that can stamp these thousands of bits at the same time. To know the size of memory blocks in yout linus system --> getconf PAGESIZE

So to get back to our text file, our system went through 3 steps:

# a- Mesuring the file: Determines the size of the file to be saved (reads metadata of the file, gets a value in bytes and converts it into block size/memory blocks) ex: file= 9 kb, blocks = 4kb ---> 3 bloks reserved. (if wondering what happens to the leftover, they are called slack memory and are...Reserved but unused...# recycle # greenwashing)

# b- Block allocation: After getting the necessary value in blocks, Checks if there is enough memory blocks to be written with our files data.
# c- File allocation: When we know there is enough blocks, the system selects the blocks and mark them as "in use" (--> like a kid in the toilet that says "occupÃ©!!").
# d- Writing process: Now that the blocks are reserved, the writing process begins. it does that with block-sized chunks (--> using the big stamp...). So in this case, the stamp hits 3 times (3 memory blocks).
# e- Now someone needs to keep track of the blocks that hold the data for our file. So a sort of general summary (inode or directory entry) is updated with these informations. 

BINGO !




------ PART 2: Tabula rasa (not another harry potter's spell) ------

Intro: JUL - oubliez-moi https://www.youtube.com/watch?v=oc-j_yW_TDw (0:50).


### 3. Erase the file completly.

// What Happened??

-----> After we instructed our computer to delete our secret file, once again, our system goes through several steps:

# a- Locating Our file: from the name of the file thta we specified in our erase command, the sytem tries to locate the memory area where our file is stored. It goes through the register (inode or directory entry) and finds the memory blocks (memory address). For the record this is how a block memory notation looks like: [0x1352].

# b- Marking the file as deleted: This step consists in erasing our file from THE general summary (once again inode or directory entry).

# c- Deallocating the blocks: Once the entry has been removed from the inode, the memory blocks onto which we had written our file are freed and marked as availlable for usage. (the kid goes out of the toilet and says "j'ai finiiiiiii").

So now if you followed well, your file should be erased. Congratulations!



### 4. Download/install photorec:

## Linux systems:

# photorec --version

If not installed:

# sudo apt/dnf/yum install testdisk

## Windows
(...)


### 5. Then create a directory name OMG on your desktop:
# mkdir OMG

### 6. Use Photorec:
## Linux systems:
#---> for demonstration purposes, I will use a .jpg file since it has more specific metadata patterns and is more easily recoverable by Photorec (compared to .txt files for exmaple).
# $sudo photorec /home/alex/Desktop/OMG /cmd /dev/sda // use lsblk before if unsure of which disk to use as a target.
Then in Photorec's menu, chose only .jpg files, save and hit search after choosing your OMG folder as a destination.

------ PART 3: Photorec. ------

// What Happened ??
---> Goes through the whole disk, bypassing the system, and investigating the memory at block level (not byte or bit level).
Let's go back to the very fisrt step when you created your file. Besides what we already saw of the file making process, there is a step that we did not cover.
During the making, there needs to be (speak about head and tail of file in memory blocks, to know where it begins and stops) (...)



------ PART 4: Erase for good. ------

Show sript and explain at block level.


###########################Test exercise on a usb key thta has a small partition (oterwise too long) and erase all memory before with script##############
